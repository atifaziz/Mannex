<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089, processorArchitecture=MSIL" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".cs" #>
#region License, Terms and Author(s)
//
// Mannex - Extension methods for .NET
// Copyright (c) 2009 Atif Aziz. All rights reserved.
//
//  Author(s):
//
//      Atif Aziz, http://www.raboof.com
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
#endregion

namespace Mannex
{
    using System;
    using System.Diagnostics;

    /// <summary>
    /// Extension methods for <see cref="Func{T}"/> and family.
    /// </summary>

    static partial class FuncExtensions
    {
        // ReSharper disable RedundantLambdaSignatureParentheses
    <#  
    Func<string, Func<int, string>> 
        fmt = prefix => x => prefix + x;

    Func<int, string> tf = fmt("T");
    Func<int, string> argf = fmt("arg");

    Func<string, Func<IEnumerable<string>, string>> 
        join0 = sep => ss => string.Join(sep, ss);
    Func<IEnumerable<string>, string> 
        join = join0(", ");

    Func<int, int, IEnumerable<int>> range = Enumerable.Range;

    var max = 3; // TODO Increase for .NET Framework 4

    var q = from x in Enumerable.Range(2, max)
            from y in Enumerable.Range(1, x - 1)
            select new 
            { 
                Args  = range(1, x).ToArray(), 
                Bound = range(1, y).ToArray(),
                Free  = range(y + 1, x - y).ToArray(), 
            };

    foreach (var i in q)
    {
        var ts    = join(i.Args.Select(tf));
        var ots   = join(i.Free.Select(tf));
        var bound = join(i.Bound.Select(x => tf(x) + " " + argf(x)));
        var free  = join(i.Free.Select(argf));
        var all   = join(i.Args.Select(argf));
        #>

        /// <summary>
        /// Partially applies the first <#= i.Bound.Count() > 1 
                                            ? i.Bound.Count() + " arguments" 
                                            : "argument" #> of
        /// <see cref="Func{<#= join0(",")(i.Args.Select(tf)) #>,TResult}"/>.
        /// </summary>

        [DebuggerStepThrough]
        public static Func<<#= ots #>, TResult> Apply<<#= ts #>, TResult>(
            this Func<<#= ts #>, TResult> func,
            <#= bound #>)
        {
            if (func == null) throw new ArgumentNullException("func");
            return (<#= free #>) => func(<#= all #>);
        }
<#  } #>
    }
}
